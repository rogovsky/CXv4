<HTML>
<HEAD>
<TITLE>Библиотека vdev</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.css">
</HEAD>
<BODY>

<H1>Библиотека vdev&nbsp;&#151; руководство программиста</H1>

	<H2>Введение</H2>

		<H3>Потребность</H3>

<P>Библиотека <CODE>vdev</CODE> (Virtual DEVice) предназначена для создания
драйверов CX-сервера, работающих с аппаратурой не напрямую, а через другие
драйверы.

<P>Выбор названия обусловлен тем, что подобные драйверы представляют как бы
"виртуальные" устройства, не существующие как управляющие устройства
напрямую, а управляемые другими устройствами <I>(сумбурное объяснение,
да...)</I>.

<P>Примеры подобных устройств:

  <UL TYPE=square>

  <LI><CODE>ist_cdac20</CODE>: источники ИСТ, ИСТР и совместимые.
Управляются через встраиваемый в них CDAC20 либо CEAC51.

  <LI><CODE>v3h_a40d16</CODE>: источники ВЧ300.  Комплект из 8 источников
управляется связкой CANDAC16 плюс CANADC40.

  <LI><CODE>vepp4_gimn</CODE>: ГИМН, стоящий во впуске из канала К500 в
ВЭПП-3М.  Управляется связкой CGVI8M с CPKS8, плюс VsDC2 (итого 3
устройства).

  </UL>

		<H3>Смысл существования vdev</H3>

  <UL TYPE=square>

  <LI>В принципе, возможно было бы вставлять специфику работы с реальными
управляющими устройствами прямо в драйверы "виртуальных устройств".  Но это:

    <OL TYPE=a>

    <LI>Является дублированием кода.

    <LI>Очень неудобно, поскольку работа с некоторыми устройствами весьма
нетривиальна и смешивание её с логикой работы "виртуальных устройств"
создало бы крайне плохо поддерживаемый спагетти-код.

    </OL>

  <LI>Дополнительный плюс отделения "виртуальных" устройств от реальных --
независимость и, как следствие, гибкость:

    <UL TYPE=square>

    <LI>Несколько виртуальных устройств могут пользоваться одним реальным,
не создавая конфликтов (поскольку реально с устройством будет работать
один-единственный драйвер).

    <LI>Одно виртуальное устройство может быть составлено из нескольких
реальных.

    <LI>Вследствие использования cda, виртуальное устройство в одном сервере
может пользоваться реальными устройствами другого сервера (в т.ч.
запущенного на другом хосте).

    </UL>

  <LI>Хотя поддерживать взаимодействие с подчинёнными устройствами можно и
напрямую через cda, но соответствующий код содержит большое количество
стандартных "ритуальных заклинаний" и, воизбежание дублирования, прекрасно
обобщается.

<P>Экспериментальная проверка -- на драйвере
<CODE>lebedev_subharmonic</CODE>, не использующем машину состояния --
показала, что при переводе на vdev код сократился на 36 строк (124 против
160).

  </UL>

		<H3>Состав</H3>

<P>Библиотека состоит из 2 частей:

  <OL>

  <LI>"Наблюдатель" (observer).  Поддерживает связь с подчинёнными
устройствами: получает значения их каналов, а также следит за их состоянием
(через

<A HREF="../_devstate.ru.html">каналы <TT>._devstate</TT></A>).

  <LI>Машина состояний.  Предоставляет реализацию специализированной машины
состояний, позволяющую отразить логику функционирования обслуживаемых
устройств (многие из них хорошо описываются в терминах машин состояний).

  </OL>

<P>Observer может использоваться самостоятельно, а машина состояний
пользуется observer'ом.

		<H3>Специфика реализации</H3>

  <UL TYPE=square>

  <LI>Взаимодействие с реальными устройствами производится через cda, по
протоколу <TT>insrv::</TT>.

  <LI>При указании в качестве базового устройства имени с префиксом
<TT>cx::</TT> можно использовать устройство из другого сервера.

<P>Причём это делается прозрачно для драйвера виртуального устройства,
просто соответствующим указанием в devlist-файле.

  <LI STYLE="font-size: smaller;">Также можно создавать многоуровневые
иерархии из виртуальных устройств, но на текущий момент (03.11.2016) таких
потребностей не возникало.

<P>10.07.2018: чё я тут имел в виду?!

  </UL>

		<H3>Терминология</H3>

<P>Далее в тексте (и в самой библиотеке <CODE>vdev</CODE>) используются
следующие термины:

  <DL>

  <DT>Контекст</DT><DD>Структура (типа <CODE>vdev_context_t</CODE>),
определяющая текущее состояние библиотеки и хранящая всю информацию для
неё.

<P>Контекст аллокируется драйвером виртуального устройства.

</DD>

  <DT>Подчинённое устройство</DT><DD>(Subordinate device) -- реальное
устройство (или устройствА), через которое драйвер виртуального устройства
общается с аппаратурой.</DD>

  <DT>sodc</DT><DD>(SubOrDinate Channel) -- канал подчинённого устройства,
номер.

<P>Драйвер виртуального устройства создаёт свою "карту" каналов подчинённого
устройства, адресуемую по номерам, по которым и идёт всё взаимодействие в
рамках vdev.

<P>Эта нумерация может и совпадать с нумерацией каналов реального целевого
устройства (определяемой в его <TT>_drv_i.h</TT>-файле), но глубокого смысла
в этом нет (особенно при использовании множественных подчинённых устройств)
и на текущий момент (03.11.2016) все драйверы-пользователи vdev имеют
собственные карты, содержащие лишь требуемые им каналы.

</DD>

  <DT>ourc</DT><DD>(OUR Channel) -- "наш канал", номер канала виртуального
устройства.</DD>

  <DT></DT><DD></DD>

  </DL>


	<H2></H2>


	<H2>ZZZZZZZZZZ</H2>

<P>У каждого состояния может быть функция, вызываемая по его активации
(например, для состояния "Включиться" -- эта функция может выставить
единичку в бит включения).

<P>Переходы между состояниями могут происходить по внешней команде
(например, "Включиться"), по значениям каналов подчинённых устройств
(например, "Блокировка"), по времени (например, после включения нужно
подождать полторы секунды перед заданием тока), либо автоматически (после
перехода в состояние X сразу делается переход в состояние Y).


	<H2>Общий порядок создания vdev-драйвера</H2>

  <UL TYPE=square>

  <LI>Прочитать документацию и пообщаться с авторами железки, чтобы
составить представление о принципах и алгоритмах её работы, включая
калибровки, разрешенные диапазоны, скорости изменения уставок, порядок
включения и выключения (а также ПЕРЕключения, буде оное имеется), сценарии
работы в нештатных ситуациях (например, блокировки).

  <LI>Составить карту каналов в файлах <TT>include/drv_i/DDD_drv_i.h</TT> и
<TT>types/DDD.devtype</TT>.  Хорошим общим вариантом является
<CODE>w50,r50</CODE> -- для обычных железок класса источников такого
количества каналов достаточно, и для первоначально-непредусмотренных также
обычно находится место.

<P>Не забыть также канал <TT>vdev_state</TT>; можно его сделать последним (в
примере выше -- 99-м).

  <LI>Сделать "скелет" драйвера, подсмотрев его в каком-нибудь похожем или
взяв за основу <TT>TEMPLATE_VDEV_drv.c</TT>.

  <LI>Сделать "логическую карту каналов подчинённого устройства" --
<CODE>enum</CODE>, где каждому целевому каналу дан индекс с именем вида
<CODE>SODC_nnn</CODE>; последней в enum'е должна быть константа
<CODE>SUBORD_NUMCHANS</CODE>, означающая размер этой карты.

  <LI>Затем заполнить таблицу описателей
<CODE>sodc2ourc_mapping[SUBORD_NUMCHANS]</CODE> (таблица обратного
маппирования <CODE>ourc2sodc[]</CODE> должна заполняться на основе этой
автоматически, методом <CODE>_init_mod()</CODE> при загрузке драйвера).

  <LI>Продумать список возможных состояний устройства для реализации на
машине состояний, и сделать <CODE>enum</CODE> с номерами этих состояний. 
Имена должны иметь вид <CODE>ddd_STATE_STATENAME</CODE> (STATENAME -- имя
состояния заглавными буквами), а заканчиваться этот enum должен константой
<CODE>ddd_STATE_count</CODE>.

<P>Если переход к некоему состоянию состоит из нескольких последовательных
состояний, реализующих сценарий этого перехода, то этим состояниям стоит
давать имена с одинаковым префиксом.

  <LI>Заполнить таблицу описателей состояний <CODE>state_descr[]</CODE>.  
Функции-проверяльщики следует называть <CODE>IsAlwdSTATENAME()</CODE>, а
функции-исполнители <CODE>SwchToSTATENAME()</CODE>.

  <LI>Реализовать "мясо" -- собственно функции-исполнители и проверяльщики.

  <LI>Реализовать обработку всяких "асинхронных" событий в
<CODE>_sodc_cb()</CODE> -- таких, как загорание блокировок, неожиданное
отключение бита включенности устройства, etc.  -- с вызовом перехода в
соответствующее состояние.

  <LI>Реализовать функцию <CODE>_rw_p()</CODE>
  
    <UL TYPE=square>

    <LI>Отработку команд перехода в разные состояния впрямую кодировать не
надо, а надо заполнить таблицу <CODE>state_related_channels[]</CODE>, плюс
небольшой общий кусочек кода в <CODE>_rw_p()</CODE>, выполняющий стандартные
для таких каналов действия (при записи 1 проверить, что если такой переход
разрешён, то выполнить этот переход).

    <LI>Также отработка TUBE-каналов делается общим кусочком кода на все
сразу.

    </UL>

<P>Если нужно лимитировать диапазон значений TUBE-канала записи, то следует
проверять это ограничение в отдельном if()'е еще ДО общего if()'а по
каналам.

  <LI>Драйвер должен уметь определять текущее состояние железки
(вкл/выкл/блок) по текущим значениям каналов управляющего модуля.  Для этого
предусматривается состояние <CODE>DETERMINE</CODE>, в которое библиотека
vdev переключает драйвер автоматически по получению значений всех важных
(<CODE>VDEV_IMPR</CODE>) каналов, а также стоит предусмотреть канал
<TT>reset_state</TT>, по записи в который 1 делается
<CODE>vdev_set_state(,_STATE_DETERMINE)</CODE>.

<P>Собственно определение текущего состояния железки, соответственно, должно
производиться в <CODE>SwchToDETERMINE()</CODE>.

<P>Там же можно и выполнять инициализацию железа.

  <LI>Сделать стандартный скрин с именем DEV.subsys.  Он полезен для
первоначальной отладки драйвера, а также нужен для возможности быстро
поразбираться с любым экземпляром.

  </UL>


	<H2></H2>


</BODY>
</HTML>

<HTML>
<HEAD>
<TITLE>Формат файлов конфигурации сервера&nbsp;&#151; devlist*.lst</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="style.css">
</HEAD>
<BODY>

<H1>Формат файлов конфигурации сервера&nbsp;&#151; devlist*.lst</H1>


 		<H2>Введение.</H2>

<P>Файлы конфигурации описывают набор аппаратуры, которую должен
обслуживать конкретный сервер.

<P>Основной конфигурируемой единицей является УСТРОЙСТВО.  При указании
устройства его каналы создаются автоматически.

<P>Резоны выбора конкретного формата рассматриваются в

<A HREF="cxsd-devlist-rationale.ru.html">отдельном документе</A>.


 		<H3>Указание конфигов.</H3>

<P>Ссылка на конфиг-информацию указывается серверу через ключ 
командной строки <TT>"-f КОНФИГ"</TT>.  Параметр КОНФИГ имеет формат
<I>[СХЕМА:]ПУТЬ</I>,  где СХЕМА: может быть <TT>file:</TT> или
<TT>db:</TT>.  В случае <TT>file:</TT> ПУТЬ является именем  файла, в
случае <TT>db:</TT>&nbsp;&#151; определяется реализацией API доступа к БД.  По
умолчанию считается схема <TT>file:</TT>, при неуказанном ключе
<TT>"-f"</TT>  используется <TT>file:./cxsd-devlist.lst</TT>. При
надобности могут быть добавлены и иные СХЕМЫ.

<P>Обычно предполагается, что имена devlist-файлов имеют вид
<TT>devlist-HOSNTAME-N.lst</TT>, где

  <UL>

  <LI>HOSTNAME -- короткое (без домена) имя узла, на котором запускается
сервер, всё в нижнем регистре; оно может быть получено командой

<BLOCKQUOTE CLASS=excerpt><CODE>hostname -s|tr A-Z a-z</CODE></BLOCKQUOTE>

  <LI>N -- номер экземпляра сервера, от 0 до 59.

  </UL>

<P>"Центр управления пульта" CX-starter использует именно такую схему
именования; при этом devlist-файлы должны располагаться в директории
<TT>~/4pult/configs/</TT>.


		<H3>Последовательность использования.</H3>

<P>Использование конфига производится в 3 этапа:

  <OL TYPE=a>

  <LI>Считывание "файла" и формирование в памяти сервера полной
информации об устройствах.

  <LI>"Создание" аппаратных каналов (отведение под них памяти,
регистрация имен, и т.п.).

  <LI>"Оживление"-инициализация устройств.

  </OL>

<P>Этапы "b" и "c" разделены для того, чтобы при надобности 
драйверу/устройству X ссылаться на каналы драйвера/устройства Y, к
моменту  инициализации X все каналы были бы уже определены, вне
зависимости от  того, в каком порядке устройства перечислены в
конфигурации.


		<H3>Общий формат.</H3>

<P>Сервер считывает конфигурацию в текстовом виде, как 
последовательный набор строк.  Этот "текстовый файл" может браться как
из  реального текстового файла на диске (для простых стендов и для
всякой  отладки), так и формироваться из БД.  Источник данных
определяется их  "добытчиком", который может быть разным, поскольку
"добытчики" реализованы  плагинами.

<P>Для гибкости конфигурирования входной текстовый поток  пропускается
через препроцессор m4.

<!--

<P>Для гибкости конфигурирования через файлы входной текстовый поток 
пропускается через простой препроцессор SMP4TD.  Тут действуют
следующие  правила:

  <UL>

  <LI>Пустые строки, а также строки, начинающиеся с символа
<TT>'#'</TT>, игнорируются.

  <LI>Строки, начинающиеся с <TT>'.'</TT>, считаются директивами
препроцессора. Сейчас поддерживаются директивы

<BLOCKQUOTE><PRE>
.define MACRO_NAME MACRO_TEXT
.undef  MACRO_NAME
</PRE></BLOCKQUOTE>

В дальнейшем будут добавлены директивы условной обработки
.if/.ifdef/.ifndef/.elif/.else/.endif и включения .include.

  <LI>Символ <TT>'$'</TT> считается началом ссылки на макрос, которая
может иметь вид <TT>$MACRO_NAME</TT> или <TT>${MACRO_NAME}</TT>.  В
дальнейшем будет добавлена форма <TT>$[АРИФМЕТИЧЕСКОЕ_ВЫРАЖЕНИЕ]</TT>.

  <LI>Поддерживается C/shell-подобное квочение при помощи символа
<TT>'\'</TT>&nbsp;&#151; <TT>\\</TT>, <TT>\a</TT>, <TT>\n</TT>, и т.д.

  </UL>

-->


 		<H2>Формат конфигурационных данных.</H2>

<P>Каждая строка имеет вид

<BLOCKQUOTE><PRE>
КОМАНДА ДАННЫЕ_СПЕЦИФИЧНЫЕ_ДЛЯ_ЭТОЙ_КОМАНДЫ...
</PRE></BLOCKQUOTE>

где КОМАНДА может быть одной из

<A HREF="#dev">dev</A>,

<A HREF="#channels">channels</A>,

<A HREF="#devtype">devtype</A>,

<A HREF="#cpoint">cpoint</A>,

<A HREF="#layerinfo">layerinfo</A>.  Индивидуальные форматы команд
описаны ниже.


 		<H3>dev</H3>

<BLOCKQUOTE><PRE>
dev  ИМЯ_УСТРОЙСТВА[:ОПЦИИ]  ТИП[/ДРАЙВЕР][@LAYER]  ИНФО_ПО_КАНАЛАМ  BUSINFO  AUXINFO
</PRE></BLOCKQUOTE>

Здесь:

  <UL>

  <LI><B>ИМЯ</B>&nbsp;&#151; уникальное имя для устройства.

  <LI><B>:ОПЦИИ</B>&nbsp;&#151; список опций, в psp-формате. 
Используется сервером.

  <LI><B>ТИП</B>&nbsp;&#151; тип устройства.  ТИП используется также
как имя драйвера, если не указан ДРАЙВЕР.

  <LI><B>ДРАЙВЕР</B>&nbsp;&#151; имя драйвера.

  <LI><B>@LAYER</B>&nbsp;&#151; опциональный компонент, указывающий,
что перед загрузкой драйвера надо загрузить указанный layer и подсунуть
его драйверу.

  <LI><B>ИНФО_ПО_КАНАЛАМ</B>&nbsp;&#151; список групп каналов
(обсуждается ниже отдельно), либо символ <TT>'~'</TT>.

  <LI><B>BUSINFO</B>&nbsp;&#151; адресная информация: набор чисел,
разделенных запятыми.  Тут указываются: для CAMAC&nbsp;&#151; позиция
блока в крейте (или позициИ), для CAN&nbsp;&#151; номер линии и адрес
блока на линии, для RS232/422/485&nbsp;&#151; номер линии и адрес
устройства на линии (если оный в том протоколе предусмотрен).

  <LI><B>AUXINFO</B>&nbsp;&#151; дополнительная
адресная/конфигурационная информация, которая не может быть упихана в
BUSINFO и представляется строкой.  Конкретный вид строки зависит от
конкретного драйвера, и парсинг также в общем случае делается самим
драйвером.

  </UL>

Примеры:

  <UL>

  <LI>CAC208 с адресом 52, подключенный к <TT>/dev/can3</TT> (2-я линия
2-й карточки), с временем интегрирования 40мс (код 5):

<BLOCKQUOTE><PRE>
dev ctl1 cac208@socketcan r24i,w8i,r8i,w8i,r1i,w1i 3,52 adc_timecode=5
</PRE></BLOCKQUOTE>

  <LI>Тот же модуль, подключенный ко 2-й линии (<TT>/dev/can1</TT>)
мамкинской коробочки под названием <TT>cgw-weld</TT>:

<BLOCKQUOTE><PRE>
dev ctl1 cac208/remdrv r24i,w8i,r8i,w8i,r1i,w1i 1,52 b:cgw-weld adc_timecode=5
</PRE></BLOCKQUOTE>

  </UL>

(Тут для простоты принято усеченное представление CAC208&nbsp;&#151;
как просто 24 канала АЦП, 8 каналов ЦАП, и регистры В/В с двойным
(байт/побитово) представлением. <TT>"b:"</TT> означает
"big-endian"&nbsp;&#151; указание порядка байт.)


 		<H4>Описание групп каналов.</H4>

<P>Каждое устройство может поддерживать несколько наборов каналов:
каналы АЦП, ЦАП, регистров В/В, настроечные, командные, ...

<P>Эти группы перечисляются в поле ИНФО_О_КАНАЛАХ через запятую, а
каждая группа имеет формат <I>kNUMt[COUNT]</I>, где:

  <UL>

  <LI><B>k</B>&nbsp;&#151; вид (kind): <TT>r</TT>&nbsp;&#151; каналы
чтения, <TT>w</TT>&nbsp;&#151; каналы записи.

  <LI><B>NUM</B>&nbsp;&#151; количество каналов в группе.

  <LI><B>t</B>&nbsp;&#151; тип данных:

    <UL>

    <LI><TT>b</TT>&nbsp;&#151; int8  (Byte);

    <LI><TT>h</TT>&nbsp;&#151; int16 (sHort);

    <LI><TT>i</TT>&nbsp;&#151; int32 (Int);

    <LI><TT>q</TT>&nbsp;&#151; int64 (Quad);

    <LI><TT>s</TT>&nbsp;&#151; single;

    <LI><TT>d</TT>&nbsp;&#151; double;

    <LI><TT>t</TT>&nbsp;&#151; text.

    <LI><TT>u</TT>&nbsp;&#151; unicode-text (32 бита на символ).

    </UL>

  <LI><B>COUNT</B>&nbsp;&#151; опциональное поле "размер в указанных
единицах", по умолчанию принимается равным 1.

</UL>

(На случай, если захочется ввести возможность указания
беззнаковости&nbsp;&#151; можно добавить опциональный префикс
<TT>'+'</TT>.)

 	Примеры:

  <UL>

  <LI><TT>r24i</TT>&nbsp;&#151;   24 канала чтения типа int32.

  <LI><TT>w8i</TT>&nbsp;&#151;    8 каналов записи типа int32.

  <LI><TT>r16b</TT>&nbsp;&#151;   16 каналов чтения типа int8.

  <LI><TT>r1t200</TT>&nbsp;&#151; один строковый канал чтения, до 200
символов.

  </UL>

<P>В строке dev вместо полного описания групп каналов может 
указываться символ <TT>'~'</TT>&nbsp;&#151; в таком случае описание
будет взято из описания  такого типа устройств.  (Естественно, указание
<TT>'~'</TT> для неописанного ранее  типа устройств является ошибкой.)


 		<H3>channels</H3>

<P>Служит для указания списка аппаратных каналов для устройства.  Имеет
форму

<BLOCKQUOTE><PRE>
channels ИМЯ_УСТРОЙСТВА {
     ИМЯ_АППАРАТНОГО_КАНАЛА1  НОМЕР_АППАРАТНОГО_КАНАЛА1
     ИМЯ_АППАРАТНОГО_КАНАЛА2  НОМЕР_АППАРАТНОГО_КАНАЛА2
     . . .
}
</PRE></BLOCKQUOTE>

<P>НОМЕР_АППАРАТНОГО_КАНАЛАn может быть как  номером, так и именем
(если это имя уже было определено ранее, либо имеется в описании
devtype для данного устройства).

<P>ИМЯ_АППАРАТНОГО_КАНАЛАn может содержать диапазон в виде
<CODE>&lt;MIN-MAX&gt;</CODE>.  Диапазон может быть только один и может быть
в любом месте имени.  При наличии диапазона НОМЕР_АППАРАТНОГО_КАНАЛАn должен
быть только номером (ссылки на имена не допускаются).  Например, строка

<BLOCKQUOTE CLASS=excerpt><PRE CLASS=excerpt>
     out&lt;0-3&gt;z 8
</PRE></BLOCKQUOTE>

создаст имена <TT>out0z</TT>, <TT>out1z</TT>, <TT>out2z</TT>,
<TT>out3z</TT>, ссылающиеся на каналы с номерами с 8 по 11 соответственно.

<P>ЗАМЕЧАНИЕ: для повышения читаемости желательно, чтобы команда channels
следовала сразу за соответствующей командой dev, но это не является
обязательным.  Поэтому, например, сначала может идти список всех устройств,
а затем&nbsp;&#151; описания их каналов.


 		<H3>devtype</H3>

<P>Позволяет описать ТИП устройства.

<BLOCKQUOTE><PRE>
devtype ТИП_УСТРОЙСТВА ИНФО_ПО_КАНАЛАМ {
     ИМЯ_АППАРАТНОГО_КАНАЛА1  НОМЕР_АППАРАТНОГО_КАНАЛА1
     ИМЯ_АППАРАТНОГО_КАНАЛА2  НОМЕР_АППАРАТНОГО_КАНАЛА2
     . . .
}
</PRE></BLOCKQUOTE>

<P>Эта команда предназначена в первую очередь для использования в
текстовых файлах конфигурации и позволяет ОДИН РАЗ указать список
каналов для некоего типа устройств; все же последующие (в данном
конфиг-файле) экземпляры устройств этого типа будут автоматически
наполняться указанными каналами.  Кроме того, в этом случае можно не
указывать ИНФО_ПО_КАНАЛАМ  для каждого экземпляра
устройства&nbsp;&#151; оно будет браться из описания типа.

  <UL>

  <LI><B>ТИП_УСТРОЙСТВА</B>&nbsp;&#151; это название именно типа
устройства, вне  зависимости от способа его подключения.  Например,
CAMAC- и CAN-модули  могут быть подключены полудюжиной разных способов
и управляться разными  драйверами, но сами устройства при этом одни и
те же, и одно и то же  описание типа используется для всех способов
подключения.

  <LI><B>ИНФО_ПО_КАНАЛАМ</B> имеет тот же формат, что и в команде dev. 

  </UL>

<P>Содержание&nbsp;&#151; ИМЯ_АППАРАТНОГО_КАНАЛАn,
НОМЕР_АППАРАТНОГО_КАНАЛАn&nbsp;&#151; полностью аналогично команде
channels.

<P>Для разнообразных стендов полезно будет иметь один, общий для  всех,
файл с описанием всех поддерживаемых системой типов устройств, и 
включать его при помощи <TT>include()</TT>.


 		<H3>cpoint</H3>

<P>Указание точек контроля.  Поддерживаются 2 формы:

<BLOCKQUOTE><PRE>
cpoint  ИМЯ_ТОЧКИ_КОНТРОЛЯ  ИМЯ_АППАРАТНОГО_КАНАЛА  [R [D<!-- [MIN MAX]-->]]
</PRE></BLOCKQUOTE>

и

<BLOCKQUOTE><PRE>
cpoint ПРЕФИКС {
     ИМЯ1 ИМЯ_АППАРАТНОГО_КАНАЛА1 [R [D<!-- [MIN MAX]-->]]
     ИМЯ2 ИМЯ_АППАРАТНОГО_КАНАЛА2 [R [D<!-- [MIN MAX]-->]]
     . . .
}
</PRE></BLOCKQUOTE>

Здесь:

  <UL>

  <LI><B>R</B>&nbsp;&#151; коэффициент перевода аппаратного значения в
операторское;

  <LI><B>D</B>&nbsp;&#151; сдвиг нуля (OperVal=HWval/R-D);

<!--  <LI><B>MIN</B> и <B>MAX</B>&nbsp;&#151; разрешенный диапазон значений
(в операторских величинах).-->

  </UL>

При неуказанности (значения по умолчанию): R=1, D=0<!--, MIN=MAX=0 (при 
MAX&lt;=MIN диапазон считается неопределенным)-->.

<P>1-я форма позволяет указать одиночную точку контроля.  2-я же
предназначена для создания групп&nbsp;&#151; результирующие имена точек
контроля будут ПРЕФИКС.ИМЯ1, ПРЕФИКС.ИМЯ2, ...

<P>2-я форма допускает также и множественные уровни&nbsp;&#151; когда
сразу после ИМЯn стоит <TT>'{'</TT>, а на следующих строках идет список
вложенных точек контроля, завершающийся строкой <TT>'}'</TT>; их имена
при этом будут ПРЕФИКС.ИМЯn.ИМЯm; этот вариант удобен для создания
иерархий из точек контроля (хотя полезен, скорее, лишь для конфигураций
в текстовых файлах).

<P>Подробнее cpoint'ы рассматриваются в

<A HREF="cpoints.ru.html">отдельном документе</A>.


 		<H3>layerinfo</H3>

<BLOCKQUOTE><PRE>
layerinfo  LAYER_NAME[:BUS_NUMBER]  ИНФОРМАЦИЯ_ДЛЯ_LAYER'а
</PRE></BLOCKQUOTE>

<P>Эта команда указывает параметры конфигурации для layer'а с именем
LAYER_NAME; для разных экземпляров шин/подключений информация может
указываться раздельно при помощи опционального суффикса :BUS_NUMBER.

<P>Может указываться даже информация для не-используемых layer'ов,
поскольку данные от всех команд layerinfo просто складываются во 
внутреннее хранилище-БД сервера (адресуемое по ключам 
<I>LAYER_NAME[:BUS_NUMBER]</I>), а каждый layer при инициализации
экземпляра  шины/подключения спрашивает у сервера, есть ли информация
для этого  экземпляра.


 		<H2>ПРИЛОЖЕНИЯ.</H2>

 		<H3>Проект с форматной строкой.</H3>

 		<H4>Формулировка проблемы.</H4>

<P>Очевидно, что, поскольку в двух приведенных выше примерах для 
команды <TT>dev</TT> используется одно и то же устройство CAC208, то в
БД должна содержаться одна и та же информация, с отличием лишь в
способе  подключения.

 	Эта информация состоит из:

  <UL>

  <LI>Имени экземпляра.

  <LI>Типа устройства.

  <LI>Информации о группах каналов (определяется типом).

  <LI>Дополнительной информации (в данном случае&nbsp;&#151;
<TT>"adc_timecode=5"</TT>).

  </UL>

<P>Однако результирующие строки с описанием для сервера получается
существенно разными.

 		<H4>Проект решения.</H4>

<P>Проблему можно решить при помощи "форматных строк", указываемых в
описании типов подключений: для подключения через
PCI-карточку+SocketCAN&nbsp;&#151; одна строка, через
коробочку&nbsp;&#151; другая.  Конкретно эти две форматные  строки
могли бы иметь вид:

<BLOCKQUOTE><PRE>
dev %n %d@socketcan %c %l,%b %a %i
</PRE></BLOCKQUOTE>

и

<BLOCKQUOTE><PRE>
dev %n %d/remdrv    %c %l,%b b:%r %a %i
</PRE></BLOCKQUOTE>

Здесь:

  <UL>

  <LI><TT>%n</TT>&nbsp;&#151;  имя экземпляра устройства    (Name);

  <LI><TT>%d</TT>&nbsp;&#151;  тип устройства               (Device);

  <LI><TT>%c</TT>&nbsp;&#151;  информация о группах каналов (Chan-info);

  <LI><TT>%l</TT>&nbsp;&#151;  номер линии                  (Line);

  <LI><TT>%b</TT>&nbsp;&#151;  адрес(а) на шине             (Bus-id);

  <LI><TT>%a</TT>&nbsp;&#151;  доп.информация               (Auxinfo);

  <LI><TT>%i</TT>&nbsp;&#151;  инициализация каналов        (Initialization);

  <LI><TT>%r</TT>&nbsp;&#151;  Имя удаленного контроллера   (Remote).

  </UL>

<P>Такое форматирование реализуется довольно просто, и является
общепринятым подходом в Unix-системах.

<P>Пара замечаний:

  <OL>

  <LI>В принципе, можно было бы указывать номер линии&nbsp;&#151;
<TT>%l</TT>&nbsp;&#151; прямо в <TT>%b</TT>, но удобнее иметь
возможность ссылаться на эти параметры раздельно.

  <LI>Аналогично, информацию об инициализации каналов&nbsp;&#151;
<TT>%i</TT>&nbsp;&#151; можно было бы автоматически добавлять к
<TT>%a</TT>, но практичнее иметь эти параметры раздельными.

  </OL>

 		<H4>Форматные строки для layerinfo.</H4>

 	Аналогичным же образом могут формироваться и строки
layerinfo&nbsp;&#151;  достаточно указывать в описании типов
подключений вторую форматную строку,  которая будет использоваться как
шаблон для layerinfo.  Например, для  layer'а socketcan, используемого
в приведенном выше примере, может  потребоваться конфигурационная
строка вида

<BLOCKQUOTE><PRE>
layerinfo socketcan:3 baudrate=125000
</PRE></BLOCKQUOTE>

которая может быть получена из шаблона

<BLOCKQUOTE><PRE>
layerinfo socketcan:%l %p
</PRE></BLOCKQUOTE>

(предполагается, что <TT>%p</TT> заменяется на список параметров для
layer'а; <TT>%l</TT>  же, аналогично <TT>dev</TT>, заменяется на номер
линии).


 		<H3>Формат AUXINFO и ИНФОРМАЦИЯ_ДЛЯ_LAYER'А.</H3>

<P>В большинстве случаев строки в AUXINFO и в ИНФОРМАЦИЯ_ДЛЯ_LAYER'А
будут иметь вид <I>ПАРАМЕТР1=ЗНАЧЕНИЕ1 ПАРАМЕТР2=ЗНАЧЕНИЕ2</I>...  Эта
форма  очень просто и удобно распарсивается при помощи модуля
paramstr_parser  (сокращенно PSP), и в описании драйвера (в
<CODE>DEFINE_DRIVER()</CODE> и в структуре  <CODE>CxsdDriverRec</CODE>)
даже может сразу быть указана PSP-таблица, так что сервер 
самостоятельно произведет парсинг AUXINFO в приватную структуру
драйвера.

<P>Данный подход также делает тривиальной передачу драйверу 
информации, что при загрузке надо инициализировать некоторые каналы: 
параметр %i составляется из пар вида ИМЯ_КАНАЛА=ЗНАЧЕНИЕ, разделяемых 
пробелами.  В этом смысле для драйвера такая инициализационная
информация  ничем не отличается от обычных параметров.

<P>Очевидным исключением из этого правила является драйвер remdrv,
который самостоятельно разбирает AUXINFO и конечную её часть отправляет
в удаленный контроллер (где, впрочем, она может парситься уже обычным 
образом при помощи PSP).


 		<H3>Пример файла конфигурации для системы с одним CAC208.</H3>

<PRE>
layerinfo socketcan:3 baudrate=125000

devtype cac208 w20i,r8i,w8i,w8i,r8i,w8i,r8i,w1i,r1i,w8i58 {
 	ADC_BEG			0
 	ADC_END			1
 	ADC_TIMECODE		2
 	ADC_MAGN		3
 	RESERVED1		4
 	DO_RESET		5
 	DO_CALIBRATE		6
 	DO_NUMCORR		7
 	ADC_MODE		8
 	OUT_MODE		9
 	DO_TABLE_DROP		10
 	DO_TABLE_ACTIVATE	11
 	DO_TABLE_START		12
 	DO_TABLE_STOP		13
 	DO_TABLE_PAUSE		14
 	DO_TABLE_RESUME		15
 	RESERVED2		16
 	RESERVED3		17
 	RESERVED4		18
 	RESERVED5		19
 	ADC0			20
 	...
 	ADC23			43
 	OUT0			44
 	...
 	OUT7			51
 	OUT_CS0			52:OUT0
 	...
 	OUT_CS7			59:OUT7
 	OUT_CUR0		60
 	...
 	OUT_CUR7		67
 	OUTRB0			68
 	...
 	OUTRB7			75
 	INPRB0			76
 	...
 	INPRB7			83
 	INPR8B			85
 	TABLE_OUT0		86
 	...
 	TABLE_OUT7		93
}

dev ctl1 cac208@socketcan ~ 3,52 adc_timecode=5
</PRE>

</BODY>
</HTML>
